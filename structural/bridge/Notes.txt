Works with new code whereas Adapter works with legacy code.

Bridge pattern decouples abstraction and Implementation
Concepts used in this are encapsulation, composition and inheritance
Mainly advantage in this pattern is that changes in abstraction (interface) will not client, since the client interacts with the Implementation of interface
eg. Drivers, JDBC

Emphasis more on composition than inheritance. It is more than composition since application is expected to change from both sides.

In JDBC exmaple, the driver acts as a bridge, since you can pass any connection string and driver to the same DriverManager.registerDriver() method to connect to MySQL, Postgres, SQLServer, H2, etc.
-> The client doesn't have to change unless the table and data changes

Another exmaple:
Say you have a printer which can print - movie, images, etc. Also you have multiple formats in which you want to see this - HTML, XML, JSON
-> so you can create 2 separate interfaces

<<Formatter>>: HTMLFormatter, JSONFormatter, etc.
<<Media>> : Movie, Image, Etc.
<<Printer>> : 
    - Media
    + print(Formatter) - this calls formatter.format and returns output

Pitfalls:
1. increases complexity
2. can be difficult to plan...since we're breaking code into interfaces, and this should be well thought
3. can be confusing on what goes where since there's a lot of abstraction on both sides

Comparison with other patterns:
w.r.t. Adapter
1. bridge is designed upfront i.e. built in advance consciously
2. more complex
3. breaks functionality into pieces (so that it works independently of one another) whereas in Adapter, we don't any functionality.

Adapter, works after the code is designed. Intended to work with legacy applications i.e. we tie something with legacy application using Adapter akak retrofitted

Summary: bridge gives flexibility although it may be complex to implement